## Resumen de avance
Loaded cached credentials.
Claro, aquí tienes el apunte de estudio basado en el commit, explicando los cambios y su importancia.

---

### **S11: Aplanando las Imágenes y Optimizando Updates con `QueryRunner` en TypeORM**

En esta lección, se introduce una refactorización crucial en el `ProductsService` para manejar las actualizaciones de productos y sus imágenes de una manera más robusta y segura, utilizando transacciones de base de datos a través de un `QueryRunner` de TypeORM.

#### **Objetivo del Cambio**

El objetivo es "aplanar" los datos que llegan en el `updateProductDto`. Esto significa que, en lugar de simplemente actualizar los campos del producto, ahora separamos la lógica para manejar las imágenes. Este proceso requiere múltiples pasos en la base de datos (primero borrar imágenes antiguas, luego insertar las nuevas y finalmente actualizar el producto). Para garantizar que todas estas operaciones se completen con éxito o fallen juntas, se introduce el concepto de **transacciones**.

#### **Código Clave y Explicación**

**1. Inyección de `DataSource`**

Para poder gestionar transacciones, necesitamos acceso al `DataSource`. Este servicio de TypeORM representa la conexión con nuestra base de datos y nos permite crear un `QueryRunner`.

// 04-teslo-shop/src/products/products.service.ts

import {
    BadRequestException,
    Injectable,
    InternalServerErrorException,
    Logger,
    NotFoundException
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { DataSource, Repository } from 'typeorm'; // Se importa DataSource

// ...

export class ProductsService {
    // ...
    constructor(
        // ...
        @InjectRepository(ProductImage)
        private readonly productImageRepository: Repository<ProductImage>,

        private readonly dataSource: DataSource, // Se inyecta el DataSource
    ) { }

// ...

**2. Refactorización del Método `update`**

El método `update` se modifica significativamente para orquestar la transacción.

*   **Desestructuración del DTO**: Se separan las `images` del resto de las propiedades del producto (`...toUpdate`). Esto nos permite manejar la actualización de las imágenes de forma independiente.
*   **Creación del `QueryRunner`**: Se utiliza `this.dataSource.createQueryRunner()` para obtener un "corredor de consultas". Este objeto será el encargado de ejecutar todas nuestras operaciones dentro de una misma transacción.

// 04-teslo-shop/src/products/products.service.ts

async update(id: string, updateProductDto: UpdateProductDto) {

    // 1. Desestructuramos las imágenes del resto del DTO
    const { images, ...toUpdate } = updateProductDto;

    // 2. Usamos preload para preparar la actualización con los datos del producto
    const product = await this.productRepository.preload({ id, ...toUpdate });

    if (!product) throw new NotFoundException(`Product with uuid ${id} not found`);

    // 3. Creamos el Query Runner para manejar la transacción
    const queryRunner = this.dataSource.createQueryRunner();


    try {
        // Aquí iría la lógica de la transacción:
        // - Conectar el queryRunner
        // - Iniciar la transacción
        // - Borrar imágenes anteriores (DELETE)
        // - Guardar las nuevas imágenes (INSERT)
        // - Guardar los cambios del producto (UPDATE)
        // - Hacer commit de la transacción

        await this.productRepository.save(product);
        return product

    } catch (error) {
        // Si algo falla, aquí se haría el rollback de la transacción
    }
}

#### **Concepto Clave: Transacciones con `QueryRunner`**

Un **`QueryRunner`** de TypeORM nos permite ejecutar una serie de operaciones en la base de datos dentro de una **transacción**. Una transacción es una unidad de trabajo que se trata como un "todo o nada".

*   **Atomicidad**: O todas las operaciones (borrar imágenes, insertar nuevas, actualizar producto) tienen éxito, o ninguna de ellas se aplica.
*   **Consistencia**: Esto evita que la base de datos quede en un estado inconsistente. Por ejemplo, si la actualización del producto funciona pero falla la inserción de las nuevas imágenes, la transacción completa se revierte (`rollback`), y la base de datos vuelve a su estado original, como si nada hubiera pasado.

#### **Importancia para el Curso**

Esta es una práctica fundamental en el desarrollo de aplicaciones robustas.

> Las transacciones son esenciales cuando una sola acción del usuario (como "actualizar un producto") implica múltiples escrituras en la base de datos que dependen entre sí. El uso de un `QueryRunner` es la forma profesional de garantizar la integridad y consistencia de los datos en escenarios complejos.

---
*Este apunte fue generado automáticamente.*
