## Resumen de apuntes
Loaded cached credentials.
Claro, aquí tienes el apunte de estudio en formato Markdown basado en el commit proporcionado.

---

# S10: Mejorando el Código con Interfaces y Tipado en Peticiones Asíncronas

En esta sesión, exploramos cómo mejorar la robustez y claridad de nuestro código al interactuar con APIs externas. El cambio principal se centra en abandonar el tipo `any`—que anula las ventajas de TypeScript—y adoptar un tipado estricto mediante interfaces.

## ¿Por Qué es Importante Tipar las Respuestas de una API?

Cuando realizamos una petición a una API con `axios` o `fetch`, TypeScript no conoce la estructura de los datos que recibiremos. Por defecto, los trata como `any`, lo que nos deja sin autocompletado y sin verificación de tipos en tiempo de compilación. Esto es propenso a errores que solo descubriremos en tiempo de ejecución.

La solución es definir explícitamente la "forma" de la respuesta de la API usando una **interfaz**.

### 1. Creación de la Interfaz de Respuesta

Se ha creado un nuevo archivo para definir la estructura de la respuesta de la PokeAPI.

**Archivo Nuevo:** `src/interfaces/pokeapi-response.interface.ts`

// Generated by https://quicktype.io

export interface PokeapiResponseInterface {
	abilities: Ability[];
	base_experience: number;
	cries: Cries;
	forms: Species[];
	game_indices: GameIndex[];
	height: number;
	held_items: any[];
	id: number;
	is_default: boolean;
	location_area_encounters: string;
	moves: Move[];
	name: string;
	order: number;
	past_abilities: any[];
	past_types: any[];
	species: Species;
	sprites: Sprites;
	stats: Stat[];
	types: Type[];
	weight: number;
}

export interface Ability {
	ability: Species;
	is_hidden: boolean;
	slot: number;
}

export interface Species {
	name: string;
	url: string;
}

// ... y otras interfaces que definen la estructura completa

> **💡 Pro-Tip:** Herramientas como [Quicktype.io](https://quicktype.io/) son increíblemente útiles. Puedes pegar una respuesta JSON de una API y generará automáticamente las interfaces en el lenguaje que necesites, ahorrándote mucho tiempo.

### 2. Aplicando el Tipado en el Código

Una vez definida la interfaz, la aplicamos en nuestra clase `Pokemon` para darle a TypeScript toda la información que necesita.

**Archivo Modificado:** `src/bases/03-clases.ts`

#### Código Anterior (Sin Tipado Estricto)

Antes, el método `getMoves` no especificaba el tipo de dato que `axios` devolvería, y el método mismo no declaraba qué tipo de `Promise` retornaba.

import axios from 'axios';

export class Pokemon {
	// ...

	async getMoves() {
		// La constante "data" es de tipo "any"
		const { data } = await axios.get('https://pokeapi.co/api/v2/pokemon/4');
		console.log(data.moves);
		return data.moves;
	}
}

#### Código Nuevo (Con Tipado Estricto)

Ahora, usamos **genéricos** en `axios` y tipamos el valor de retorno de la función.

import axios from 'axios';
// 1. Importamos la interfaz principal y el tipo específico que necesitamos
import {
	PokeapiResponseInterface,
	Move,
} from '../interfaces/pokeapi-response.interface';

export class Pokemon {
	// ...

	// 2. Tipamos el valor de retorno del método asíncrono
	async getMoves(): Promise<Move[]> {
		// 3. Usamos un genérico para decirle a axios cómo luce la data
		const { data } = await axios.get<PokeapiResponseInterface>(
			'https://pokeapi.co/api/v2/pokemon/4'
		);

		// Ahora TypeScript sabe que "data.moves" es un array de tipo "Move"
		console.log(data.moves);
		return data.moves;
	}
}

## Conclusiones Clave

1.  **Interfaces para Contratos de API:** Las interfaces son la herramienta fundamental en TypeScript para describir la estructura de objetos, especialmente los que provienen de fuentes externas como las APIs.
2.  **Genéricos en `axios`:** Al usar `axios.get<MiInterfaz>(...)`, le proporcionamos a `axios` (y a TypeScript) el "molde" de la respuesta. Esto activa el autocompletado y la detección de errores en nuestro editor de código.
3.  **Tipado en Métodos Asíncronos:** Declarar el tipo de retorno como `Promise<TipoDeDato>` hace que el contrato de nuestro método sea explícito y seguro, mejorando la predictibilidad y mantenibilidad del código.

---
*Este apunte fue generado automáticamente.*
