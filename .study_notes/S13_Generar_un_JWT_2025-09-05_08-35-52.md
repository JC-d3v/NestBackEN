## Resumen de avance
Claro, aquí tienes el apunte de estudio en formato Markdown basado en los cambios del commit.

# S13: Generación de JSON Web Tokens (JWT)

En esta sesión, integramos la generación de JSON Web Tokens (JWT) en nuestro sistema de autenticación. Ahora, cuando un usuario se registra o inicia sesión con éxito, el backend no solo confirma la operación, sino que también le entrega un token de acceso. Este token es esencial para que el usuario pueda interactuar con las rutas protegidas de la aplicación en el futuro.

Adicionalmente, se implementaron mejoras en la entidad `User` para sanitizar y estandarizar los datos antes de que se guarden en la base de datos, asegurando una mayor integridad de la información.

## Puntos Clave del Aprendizaje

1.  **Integración de `JwtService`**: Cómo inyectar y utilizar el servicio de JWT de NestJS para crear tokens.
2.  **Generación de JWT**: El proceso de firmar un *payload* para generar un token único.
3.  **Modificación de la Respuesta de Autenticación**: Cómo devolver el token junto con los datos del usuario.
4.  **Hooks de TypeORM**: El uso de los decoradores `@BeforeInsert` y `@BeforeUpdate` para ejecutar lógica antes de las operaciones de base de datos.

---

## Análisis del Código

### 1. `auth.service.ts` — Integrando el `JwtService`

Para generar los tokens, inyectamos `JwtService` en nuestro `AuthService`. Este servicio, parte del módulo `@nestjs/jwt`, nos proporciona las herramientas necesarias para crear y manejar JWTs.

**Inyección de Dependencias en el Constructor:**

// 04-teslo-shop/src/auth/auth.service.ts

import { JwtService } from '@nestjs/jwt';
// ...
import { JwtPayload } from './interfaces/jwt-payload.interface';


@Injectable()
export class AuthService {
	// ...

	constructor(
		@InjectRepository(User)
		private readonly userRepository: Repository<User>,

		private readonly jwtService: JwtService, // Se inyecta el servicio
	) { }

// ...

**Nuevo Método Privado para Generar el Token:**

Se creó un método auxiliar, `getJwtToken`, para encapsular la lógica de creación del token. Este método recibe un `payload` (la información que queremos codificar en el token) y utiliza `jwtService.sign()` para generar el string del JWT.

// 04-teslo-shop/src/auth/auth.service.ts

	private getJwtToken( payload: JwtPayload ) {
		const token = this.jwtService.sign( payload );
		return token;
	}

**Actualización de los Métodos `create` y `login`:**

Ambos métodos ahora devuelven un objeto que incluye los datos del usuario y el token generado. Se elimina la contraseña del objeto de usuario por seguridad antes de enviarlo como respuesta.

// 04-teslo-shop/src/auth/auth.service.ts

	// Método login (similar para el método create)
	async login( loginUserDto: LoginUserDto ) {
		// ... (validaciones previas)

		// Se retorna el usuario y el token
		return {
			...user,
			token: this.getJwtToken({ email: user.email })
		};
	}

### 2. `user.entity.ts` — Sanitización de Datos con Hooks

Para asegurar la consistencia de los datos, utilizamos los *hooks* de ciclo de vida de TypeORM. Estos decoradores nos permiten ejecutar código automáticamente en ciertos eventos de la entidad.

-   `@BeforeInsert()`: Se ejecuta justo antes de que una nueva entidad sea guardada en la base de datos.
-   `@BeforeUpdate()`: Se ejecuta antes de que una entidad existente sea actualizada.

En este caso, los usamos para convertir el email a minúsculas y eliminar espacios en blanco, evitando así posibles duplicados o inconsistencias.

// 04-teslo-shop/src/auth/entities/user.entity.ts

import { BeforeInsert, BeforeUpdate, Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity('users')
export class User {
	
	// ... (propiedades de la entidad)

	@BeforeInsert()
	chechFieldsBeforeInsert() {
		this.email = this.email.toLowerCase().trim()
	}

	@BeforeUpdate()
	chechFieldsBeforeUpdate() {
		this.chechFieldsBeforeInsert();
	}
}

## Conclusión

Con estos cambios, nuestro sistema de autenticación ha evolucionado significativamente. Ya no solo validamos credenciales, sino que también generamos un JWT que servirá como "llave" para que los usuarios accedan a las partes seguras de nuestra aplicación. El uso de hooks de TypeORM también refuerza la calidad y la integridad de nuestros datos desde el modelo de la base de datos.
