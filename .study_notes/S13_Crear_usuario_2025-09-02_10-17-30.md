## Resumen de avance
Claro, aquí tienes el apunte de estudio en formato Markdown basado en los cambios del commit.

# S13: Creación de Usuario y Manejo de Contraseñas

En esta sección, implementamos la funcionalidad de registro de usuarios. El objetivo es crear un endpoint que reciba los datos de un nuevo usuario, los valide y los persista en la base de datos. Esto implica la creación de un DTO específico para la validación, la actualización de la entidad `User` y la implementación de la lógica de negocio en el servicio, incluyendo un manejo de errores robusto.

---

### 1. Actualización de la Entidad `User`

Para asegurar que los nuevos usuarios estén activos por defecto, modificamos la entidad `User`.

**`04-teslo-shop/src/auth/entities/user.entity.ts`**

import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity({ name: 'users' })
export class User {
	// ... otras propiedades
	@Column('text')
	fullName: string;

	@Column('bool', {
		default: true,
	})
	isActive: boolean;

	@Column('json', {
		// ...
	});
}

-   **`@Column('bool', { default: true })`**: Se especifica que la columna `isActive` es de tipo booleano y tendrá un valor por defecto de `true` en la base de datos. Esto simplifica la lógica de creación, ya que no necesitamos establecer este valor manualmente cada vez.

---

### 2. DTO para Creación y Validación de Usuarios

Se crea un DTO (`Data Transfer Object`) para definir la estructura de los datos que esperamos recibir al crear un usuario. Usamos `class-validator` para asegurar que los datos cumplan con reglas específicas antes de ser procesados.

**`04-teslo-shop/src/auth/dto/create-user.dto.ts`**

import {
	IsEmail,
	IsString,
	IsStrongPassword,
	MaxLength,
	MinLength,
} from 'class-validator';

export class CreateUserDto {
	@IsString()
	@IsEmail()
	email: string;

	@IsString()
	@MaxLength(50)
	@IsStrongPassword({
		minLength: 6,
		minLowercase: 1,
		minUppercase: 1,
		minNumbers: 1,
		minSymbols: 1,
	})
	password: string;

	@IsString()
	@MinLength(1)
	fullName: string;
}

-   **`@IsEmail()`**: Valida que el campo `email` tenga un formato de correo electrónico válido.
-   **`@IsStrongPassword()`**: Es un validador muy útil que impone requisitos de seguridad a la contraseña, como una longitud mínima y la inclusión de mayúsculas, minúsculas, números y símbolos. Esto es crucial para la seguridad de las cuentas.

---

### 3. Controlador de Autenticación

El controlador se simplifica para exponer un único endpoint de registro (`/auth/register`).

**`04-teslo-shop/src/auth/auth.controller.ts`**

import { Controller, Post, Body } from '@nestjs/common';
import { AuthService } from './auth.service';
import { CreateUserDto } from './dto/create-user.dto';

@Controller('auth')
export class AuthController {
	constructor(private readonly authService: AuthService) {}

	@Post('register')
	create(@Body() createUserDto: CreateUserDto) {
		return this.authService.create(createUserDto);
	}
}

-   **`@Post('register')`**: Define una ruta `POST` en `/auth/register`.
-   **`@Body() createUserDto: CreateUserDto`**: Extrae el cuerpo de la petición y lo valida automáticamente contra las reglas definidas en `CreateUserDto`. Si la validación falla, NestJS devuelve un error `400 Bad Request` sin que tengamos que escribir código adicional.

---

### 4. Lógica del Servicio y Manejo de Errores

El servicio de autenticación contiene la lógica principal para interactuar con la base de datos y manejar posibles errores.

**`04-teslo-shop/src/auth/auth.service.ts`**

import {
	BadRequestException,
	Injectable,
	InternalServerErrorException,
	Logger,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';

import { CreateUserDto } from './dto/create-user.dto';
import { User } from './entities/user.entity';

@Injectable()
export class AuthService {
	private readonly logger = new Logger('AuthService');

	constructor(
		@InjectRepository(User)
		private readonly userRepository: Repository<User>,
	) {}

	async create(createUserDto: CreateUserDto) {
		try {
			const user = this.userRepository.create(createUserDto);
			await this.userRepository.save(user);
			return user;
		} catch (error) {
			this.handleDbExceptions(error);
		}
	}

	private handleDbExceptions(error: any): never {
		if (error.errno === 1062) {
			throw new BadRequestException(error.sqlMessage);
		}

		this.logger.error(error);
		throw new InternalServerErrorException(
			'Unexcpeced error check server logs!!!',
		);
	}
}

-   **`@InjectRepository(User)`**: Inyecta el repositorio de TypeORM para la entidad `User`, permitiendo la interacción con la tabla `users`.
-   **`create(createUserDto)`**:
    1.  `this.userRepository.create(createUserDto)`: Crea una instancia de la entidad `User` a partir del DTO.
    2.  `this.userRepository.save(user)`: Guarda la nueva instancia en la base de datos.
-   **`handleDbExceptions(error)`**:
    -   Este método centraliza el manejo de errores de la base de datos.
    -   Verifica si el código de error es `1062` (error de entrada duplicada en MySQL), y si es así, lanza una excepción `BadRequestException` con un mensaje claro.
    -   Para cualquier otro error, lo registra usando `Logger` y lanza una excepción genérica `InternalServerErrorException` para no exponer detalles sensibles de la implementación.
