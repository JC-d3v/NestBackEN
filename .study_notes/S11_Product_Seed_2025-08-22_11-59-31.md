## Resumen de avance
Loaded cached credentials.
Claro, aquí tienes el apunte de estudio en formato Markdown basado en el commit proporcionado.

# S11 — Product Seed

En esta sesión, exploraremos la implementación de un "seed" para nuestra base de datos. Un seed es un proceso que puebla la base de datos con datos iniciales, lo cual es fundamental para entornos de desarrollo y pruebas. Crearemos un módulo dedicado para esta funcionalidad, asegurando que nuestro código se mantenga organizado y modular.

## Puntos Clave

1.  **Creación del Módulo `SeedModule`**: Se introduce un nuevo módulo para manejar la lógica de la siembra de datos.
2.  **Exportación de Módulos y Servicios**: Se ajusta `ProductsModule` para exportar sus capacidades y permitir que otros módulos las utilicen.
3.  **Endpoint para Ejecutar el Seed**: Se crea un controlador con un endpoint específico para disparar el proceso de siembra.
4.  **Inyección de Dependencias entre Módulos**: El nuevo `SeedService` inyecta y utiliza `ProductsService` para interactuar con la base de datos.

---

### 1. Integración del `SeedModule` en la Aplicación

Para que NestJS reconozca nuestro nuevo módulo, lo importamos en el módulo principal de la aplicación, `app.module.ts`.

// 04-teslo-shop/src/app.module.ts

import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ProductsModule } from './products/products.module';
import { CommonModule } from './common/common.module';
import { SeedModule } from './seed/seed.module';

@Module({
    imports: [
        ConfigModule.forRoot(),
        TypeOrmModule.forRoot({
            type: 'postgres',
            host: process.env.DB_HOST,
            port: +process.env.DB_PORT,
            database: process.env.DB_NAME,
            username: process.env.DB_USERNAME,
            password: process.env.DB_PASSWORD,
            autoLoadEntities: true,
            synchronize: true,
        }),
        ProductsModule,
        CommonModule,
        SeedModule // Se añade el nuevo módulo
    ],
    controllers: [],
    providers: [],
})
export class AppModule {}

### 2. Exportando Funcionalidades en `ProductsModule`

Para que `SeedModule` pueda utilizar `ProductsService` y las entidades de `Product`, necesitamos exportarlos desde `ProductsModule`. Esto es un principio clave de la encapsulación en NestJS: por defecto, los módulos no exponen sus "providers".

// 04-teslo-shop/src/products/products.module.ts

import { Module } from '@nestjs/common';
import { ProductsService } from './products.service';
import { ProductsController } from './products.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Product, ProductImage } from './entities';

@Module({
    controllers: [ProductsController],
    providers: [ProductsService],
    imports: [TypeOrmModule.forFeature([Product, ProductImage])],
    // Exportamos TypeOrmModule y ProductsService para que otros módulos puedan usarlos
    exports: [ProductsService, TypeOrmModule]
})
export class ProductsModule {}

### 3. Creación del `SeedModule`

Este nuevo módulo agrupa el controlador y el servicio dedicados a la siembra de datos. Importa `ProductsModule` para tener acceso al `ProductsService` que acabamos de exportar.

// 04-teslo-shop/src/seed/seed.module.ts

import { Module } from '@nestjs/common';
import { SeedService } from './seed.service';
import { SeedController } from './seed.controller';
import { ProductsModule } from 'src/products/products.module';

@Module({
    controllers: [SeedController],
    providers: [SeedService],
    imports: [ProductsModule] // Importamos el módulo para usar sus exports
})
export class SeedModule {}

### 4. El Controlador del Seed (`SeedController`)

Este controlador expone un endpoint `GET /seed`. Cuando se realiza una petición a esta ruta, se ejecuta el método `runSeed` del `SeedService`.

// 04-teslo-shop/src/seed/seed.controller.ts

import { Controller, Get } from '@nestjs/common';
import { SeedService } from './seed.service';

@Controller('seed')
export class SeedController {
    constructor(private readonly seedService: SeedService) {}

    @Get()
    exceuteSeed() {
        return this.seedService.runSeed();
    }
}

### 5. La Lógica del Seed (`SeedService`)

Aquí reside la lógica principal. Inyectamos `ProductsService` para poder interactuar con la tabla de productos. El método `runSeed` orquesta las operaciones de siembra. Como primer paso, implementamos una función para purgar todos los productos existentes.

// 04-teslo-shop/src/seed/seed.service.ts

import { Injectable } from '@nestjs/common';
import { ProductsService } from 'src/products/products.service';

@Injectable()
export class SeedService {

    constructor(
        private readonly productsService: ProductsService
    ) {}

    async runSeed() {
        // Orquestador del proceso de siembra
        await this.insertNewProduct();
        return "SEED EXECUTED";
    }

    private async insertNewProduct() {
        // Llama al servicio de productos para borrar todos los registros
        await this.productsService.deleteAllProducts();
        return true;
    }
}

## Conclusión

Este commit establece una base sólida y modular para la siembra de datos. Hemos aprendido la importancia de **exportar** funcionalidades desde un módulo para que puedan ser reutilizadas por otros, manteniendo al mismo tiempo una arquitectura limpia y desacoplada. El nuevo endpoint `/seed` nos proporciona una manera sencilla de reiniciar y poblar nuestra base de datos durante el desarrollo.

---
*Este apunte fue generado automáticamente.*
