## Resumen de avance
Claro, aquí tienes el apunte de estudio en formato Markdown basado en el commit proporcionado.

# S13: Login de Usuario

En esta sección, implementamos la funcionalidad de **login** para los usuarios. Esto implica crear un nuevo endpoint, validar las credenciales del usuario y verificar la contraseña de forma segura.

### 1. Ocultar la Contraseña por Defecto

Para mejorar la seguridad, es crucial que la contraseña del usuario no se envíe en las respuestas de nuestras consultas a la base de datos.

Modificamos la entidad `User` para que el campo `password` no se seleccione por defecto en ninguna consulta.

_`04-teslo-shop/src/auth/entities/user.entity.ts`_
@Column('text', { select: false })
password: string;
> **Importante:** La opción `{ select: false }` le indica a TypeORM que esta columna debe ser excluida de cualquier consulta `SELECT` a menos que se pida explícitamente.

---

### 2. Creación del DTO para el Login

Creamos un `Data Transfer Object` (DTO) específico para el login que nos permitirá validar la información que llega en el `body` de la petición.

_`04-teslo-shop/src/auth/dto/login-user.dto.ts`_
import { IsEmail, IsString, IsStrongPassword, MaxLength } from "class-validator";

export class LoginUserDto {

	@IsString()
	@IsEmail()
	email: string;

	@IsString()
	@MaxLength(50)
	@IsStrongPassword({
		minLength: 6,
		minLowercase: 1,
		minUppercase: 1,
		minNumbers: 1,
		minSymbols: 1,
	})
	password: string;

}
> Utilizamos `class-validator` para asegurar que el `email` sea un correo válido y que la `password` cumpla con los requisitos de seguridad definidos.

Adicionalmente, creamos un archivo "de barril" (`index.ts`) para simplificar las importaciones de nuestros DTOs.

_`04-teslo-shop/src/auth/dto/index.ts`_
export { CreateUserDto } from "./create-user.dto";
export { LoginUserDto } from "./login-user.dto";

---

### 3. Endpoint de Login en el Controlador

Añadimos un nuevo método en `AuthController` para manejar las peticiones `POST` en la ruta `/auth/login`.

_`04-teslo-shop/src/auth/auth.controller.ts`_
import { Controller, Post, Body } from '@nestjs/common';
import { AuthService } from './auth.service';
import { CreateUserDto, LoginUserDto } from './dto/index';

@Controller('auth')
export class AuthController {
	constructor(private readonly authService: AuthService) { }

	@Post('register')
	createUser(@Body() createUserDto: CreateUserDto) {
		return this.authService.create(createUserDto);
	}

	@Post('login')
	linkUser(@Body() loginUserDto: LoginUserDto) {
		return this.authService.login(loginUserDto);
	}
}
> El método `linkUser` recibe el `loginUserDto` y delega la lógica de autenticación al `AuthService`.

---

### 4. Lógica de Autenticación en el Servicio

El `AuthService` contiene la lógica principal para validar las credenciales del usuario.

_`04-teslo-shop/src/auth/auth.service.ts`_
import { Injectable, UnauthorizedException } from '@nestjs/common';
import * as bcrypt from 'bcrypt';
// ... otras importaciones

@Injectable()
export class AuthService {

	// ... constructor y método create

	async login(loginUserDto: LoginUserDto) {

		const { password, email } = loginUserDto;

		const user = await this.userRepository.findOne({
			where: { email },
			select: {
				email: true,
				password: true
			}
		})

		if (!user)
			throw new UnauthorizedException('Credencials are not valid (email)')

		if (!bcrypt.compareSync(password, user.password))
			throw new UnauthorizedException('Credencials are not valid (password)')

		return user;

		// TODO: retornar el JWT
	}
}

#### Análisis de la Lógica:
1.  **Búsqueda del Usuario:**
    *   Buscamos un usuario por su `email`.
    *   Usamos la opción `select` para pedir explícitamente la `password`, que de otro modo estaría oculta gracias al cambio en la entidad.

2.  **Validación de Credenciales:**
    *   Si el usuario no existe, lanzamos una `UnauthorizedException`.
    *   Comparamos la contraseña enviada (`password`) con la almacenada en la base de datos (`user.password`) usando `bcrypt.compareSync()`. Esta función se encarga de aplicar el mismo algoritmo de hash a la contraseña recibida y comparar el resultado con el hash almacenado, lo cual es un proceso seguro que no requiere desencriptar nada.
    *   Si las contraseñas no coinciden, lanzamos otra `UnauthorizedException`.

3.  **Respuesta Exitosa:**
    *   Si ambas validaciones son correctas, por ahora retornamos el objeto del usuario. En futuras lecciones, aquí generaremos y retornaremos un **JSON Web Token (JWT)**.
