## Resumen de avance
Claro, aquí tienes el apunte de estudio en formato Markdown basado en los cambios del commit.

# Estrategia de Autenticación con JWT (JwtStrategy)

En esta sección, implementamos la `JwtStrategy` utilizando Passport. Esta estrategia es fundamental para proteger nuestras rutas, ya que se encarga de validar los JSON Web Tokens (JWT) que vienen en las solicitudes de los clientes, verificando su autenticidad y asegurando que el usuario asociado al token tiene permiso para acceder al recurso.

---

### 1. Actualización del Módulo de Autenticación (`auth.module.ts`)

Para integrar la nueva estrategia, necesitamos actualizar nuestro `AuthModule`.

-   **Providers**: Se añade `JwtStrategy` a la lista de proveedores para que NestJS pueda inyectarla donde sea necesario.
-   **Imports**: Se importa `ConfigModule` para poder acceder a las variables de entorno de forma segura.
-   **Configuración de `JwtModule`**: Se modifica `JwtModule.register` por `JwtModule.registerAsync`. Esto nos permite configurar el módulo de forma asíncrona, utilizando `ConfigService` para obtener el `JWT_SECRET` y el tiempo de expiración (`JWT_EXPIRES_IN`) desde nuestras variables de entorno. Esto es una buena práctica para no "quemar" valores sensibles en el código.
-   **Exports**: Se exportan `JwtStrategy`, `PassportModule` y `JwtModule`. Esto es crucial para que otros módulos que importen `AuthModule` puedan utilizar la estrategia de JWT y los guardias de autenticación (`AuthGuard`) que dependen de ella.

// 04-teslo-shop/src/auth/auth.module.ts

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './entities/user.entity';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { JwtStrategy } from './strategies/jwt.strategy';


@Module({
	controllers: [AuthController],
	providers: [AuthService, JwtStrategy],
	imports: [
		ConfigModule,
		TypeOrmModule.forFeature([User]),

		PassportModule.register({ defaultStrategy: 'jwt' }),

		JwtModule.registerAsync({
			imports: [ConfigModule],
			inject: [ConfigService],
			useFactory: (configService: ConfigService) => {
				return {
					secret: configService.get('JWT_SECRET'),
					signOptions: {
						expiresIn: configService.get('JWT_EXPIRES_IN')
					}
				}
			}
		}),
	],
	exports: [TypeOrmModule, JwtStrategy, PassportModule, JwtModule]
})
export class AuthModule { }

---

### 2. Definiendo el Payload del JWT (`jwt-payload.interface.ts`)

Es una buena práctica definir la "forma" que tendrán los datos que guardamos dentro del JWT. Para ello, creamos la interfaz `JwtPayload`.

-   **Propósito**: Asegura que siempre sepamos qué información contiene nuestro token y nos proporciona autocompletado y tipado estático.
-   **Contenido**: Por ahora, solo contiene el `email` del usuario. En el futuro, podríamos añadir roles, permisos u otra información relevante.

// 04-teslo-shop/src/auth/interfaces/jwt-payload.interface.ts

export interface JwtPayload {
	email: string;

	// TODO: TODAS ACCIONES QUE SE VEAN CONVENIENTES
}

---

### 3. Implementación de la Estrategia JWT (`jwt.strategy.ts`)

Este es el núcleo de la validación de tokens. La clase `JwtStrategy` se encarga de recibir el JWT, decodificarlo y validar su contenido.

-   **Herencia**: Extiende de `PassportStrategy(Strategy)`, integrándose con el ecosistema de Passport.
-   **Inyección de Dependencias**:
    -   `userRepository`: Para buscar y validar al usuario en la base de datos.
    -   `ConfigService`: Para obtener el `JWT_SECRET` de las variables de entorno.
-   **Constructor**:
    -   Se llama a `super()` para pasar la configuración a la clase base `PassportStrategy`.
    -   `secretOrKey`: Especifica el secreto para verificar la firma del token.
    -   `jwtFromRequest`: Define cómo se extraerá el JWT de la solicitud. `ExtractJwt.fromAuthHeaderAsBearerToken()` es el método estándar, que busca el token en el encabezado `Authorization` con el prefijo `Bearer `.
-   **Método `validate`**:
    -   Este método se invoca automáticamente después de que Passport decodifica y verifica el token con éxito.
    -   Recibe el `payload` del token como argumento.
    -   Usa el `email` del payload para buscar al usuario en la base de datos.
    -   **Validaciones Clave**:
        1.  Si el usuario no existe (`!user`), se lanza una excepción `UnauthorizedException`.
        2.  Si el usuario existe pero está inactivo (`!user.isActive`), también se deniega el acceso.
    -   **Retorno Exitoso**: Si todas las validaciones pasan, se retorna el objeto `user` completo. Passport adjuntará este objeto al `Request` de la solicitud (accesible como `req.user`), lo que nos permite identificar al usuario autenticado en nuestros controladores.

// 04-teslo-shop/src/auth/strategies/jwt.strategy.ts

import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtPayload } from './../interfaces/jwt-payload.interface';
import { PassportStrategy } from "@nestjs/passport";
import { ExtractJwt, Strategy } from "passport-jwt";
import { InjectRepository } from '@nestjs/typeorm';
import { User } from '../entities/user.entity';
import { Repository } from 'typeorm';
import { ConfigService } from '@nestjs/config';


@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {

	constructor(
		@InjectRepository(User)
		private readonly userRepository: Repository<User>,
		configService: ConfigService

	) {

		super({
			secretOrKey: configService.get('JWT_SECRET'),
			jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
		})
	}


	async validate(payload: JwtPayload): Promise<User> {

		const { email } = payload;

		const user = await this.userRepository.findOneBy({ email });

		if (!user)
			throw new UnauthorizedException('Token not valid...');

		if (!user.isActive)
			throw new UnauthorizedException('User is Inactive...');

		return user;
	}
}

### Conclusión

Con esta implementación, cualquier ruta protegida por un `AuthGuard('jwt')` ahora usará esta estrategia para validar al usuario. Si el token es válido y el usuario existe y está activo, la solicitud procederá; de lo contrario, será rechazada con un error `401 Unauthorized`. Esto establece un mecanismo de autenticación robusto y seguro basado en tokens.
